#!/usr/bin/env python
# coding: utf-8
#
# Copyright (c) 2020-2021 Arm Ltd.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Plot s-LLGS/FPE evolution.

Please, setup all the required parameters.
Inputs are the files generated by stochastic_multithread_simulation.py
"""

import numpy as np
import matplotlib.pyplot as plt
import itertools
import matplotlib.colors as mcolors

import fooker_plank.analytical as analytical
import python_compact_model.sllgs_solver as sllgs_solver
import sllgs_importer as sllgs_i

######################################################################
# PARAMS for building llgs object
# these should match the ones you used for the s-LLGS simulation
######################################################################
# Define a macrospin mesh (i.e. one discretisation cell).
z0 = 1
initial_m = None  # np.array([0.01, 0.01, z0])  # vector in x direction
diam = 50e-9
t_fl = 1.e-9
temperature = 300
k_i_0 = 1.0e-3
alpha = 0.01  # Gilbert damping
Ms = 1.2e6  # magnetisation saturation (A/m)
# Zeeman (external field) validation
Hext = (0., 0., 0.)  # low external magnetic field (A/m) (test anisotropy)
# stt params
eps_prime = 0.0                 # [FITTING] constant
P = 0.75
Lambda = 1.

###################################
sllgs_files = [
    'path_to_csv_file_exported_by_stochastic_multithread_simulation.py',
]
sllgs_time_files = [
    'path_to_time_csv_file_exported_by_stochastic_multithread_simulation.py',
]
I0_uA = [50]*len(sllgs_files)
t_delays_ns = [5]*len(sllgs_files)

ps_sslgs = [None] * len(t_delays_ns)
time_sslgs = [None] * len(t_delays_ns)
ps_fp = [None] * len(t_delays_ns)
time_fp = [None] * len(t_delays_ns)
compute_analytical_manual = False
plot_intermediate = False
colors = itertools.cycle(mcolors.TABLEAU_COLORS)


def test_h_ext(t):
    """Set H_ext."""
    return np.array(Hext)


def test_current(t):
    """Test current."""
    return 0.


# get Ic, tau_d etc
llg_o = sllgs_solver.LLG(w_fl=diam, l_fl=diam, t_fl=t_fl,
                ms=Ms,
                alpha=alpha,
                k_i_0=k_i_0,
                # thermal_stability_0=thermal_stability_0,
                temperature=temperature,
                stt_mode='stt_oommf_simple',
                p=P,
                lambda_s=Lambda,
                eps_prime=eps_prime,
                # not include temperature noise,
                # and do not force its effects on the theta_0
                do_thermal=False,
                do_fake_thermal=False,
                do_theta_windowing=False,
                m_init=initial_m,
                # shape_ani_demag_mode=0,
                # theta_init=0.09,
                theta_pl=0.0,                  # [rad] pinned layer theta
                phi_pl=0.0,                    # [rad] pinned layer phi
                h_ext_cart=test_h_ext,
                i_amp_fn=test_current)

print(f'P: {P}, P/2: {P/2}, eps: {llg_o.get_epsilon_stt(1)}')

##############################################################################
# importing raw data
# ~/SharePoint/ProjectEnergyScalableMRAM/docs/essderc_2021/raw_data
##############################################################################


def analyze_s_llgs_tolerances(data_file, time_file, t_delay, I0_uA,
                              compute_analytical_manual=False,
                              plot_intermediate=True,
                              dim_points=1000):
    """Analyze s-LLGS."""
    # get all data, note it is not delayed anymore
    sllgs_time, sllgs_data, sllgs_sw_idx, sllgs_sw_ps = sllgs_i.process_sllgs_data(
        data_file, time_file, t_delay, dim_points)
    theta_axis = np.linspace(np.pi, 0, dim_points)

    # debug sllgs
    # return {
    #         'sllgs_time': sllgs_time,
    #         'sllgs_theta': theta_axis,
    #         'sllgs_data': sllgs_data,
    #         'sllgs_ps': sllgs_sw_ps
    #         }
    ########################################################################
    # Initializations
    I0 = np.sign(z0)*I0_uA*1e-6

    lin_space_z = False
    L0_max = 200
    Nmax = L0_max

    # maxwell_loc = -0.016632336229383336
    # maxwell_scale = 0.041628860303107654
    maxwell_loc = None
    maxwell_scale = None

    # i, h, delta
    # llg_o.ic = llg_o.ic * 1.1
    # llg_o.tau_d = llg_o.tau_d * 1.1
    print(f'Ic from: {llg_o._get_Ic()}')
    ic = np.abs(llg_o._get_Ic())
    # ic = 4*llg.c_E * llg_o.alpha * llg_o.thermal_stability * \
    #     llg.c_KB * temperature / (llg.c_hbar * llg_o.get_epsilon_stt(1)*2)
    print(f'Ic from compact modeling: {ic}')
    print(f'epsilon: {llg_o.get_epsilon_stt(1)}')
    i = I0/ic
    print(f'[debug] i: {i}')
    h = 0
    delta = llg_o.thermal_stability

    # FP Data
    xlim = sllgs_time[-1]
    tau = xlim/np.abs(llg_o._get_tau_d())
    tau_step = 0.2e-9/np.abs(llg_o._get_tau_d())
    t_pulse = 60e-9
    print(f't_final: {xlim}')
    print(f'tau: {tau} i: {i}')
    lin_space_z = False
    rho_0_at_pi = z0 < 0

    s_rho_0_fit = np.polynomial.legendre.legfit(
        x=np.cos(theta_axis),
        # sllgs is normalized to 1 already
        y=sllgs_data[:, 0][::-1],
        deg=L0_max)
    _, rho_0_a, s_rho_0_a = analytical.get_state_rho_0(
        delta=delta,
        do_maxwell=True,
        maxwell_loc=maxwell_loc,
        maxwell_scale=maxwell_scale,
        L0=Nmax,
        lin_space_z=lin_space_z,
        rho_0_at_pi=rho_0_at_pi)
    _, _, s_rho_0_b = analytical.get_state_rho_0(delta=delta,
                                                 do_maxwell=False,
                                                 L0=Nmax,
                                                 dim_points=dim_points,
                                                 lin_space_z=lin_space_z,
                                                 rho_0_at_pi=rho_0_at_pi)

    # fergar01
    # s_rho_0_fit = s_rho_0_b

    fp_theta, ddata_fit = analytical.untangle_state(s_rho_0_fit,
                                                    dim_points=dim_points,
                                                    lin_space_z=lin_space_z)
    fp_theta, ddata_a = analytical.untangle_state(s_rho_0_a,
                                                  lin_space_z=lin_space_z,
                                                  dim_points=dim_points)
    fp_theta, ddata_b = analytical.untangle_state(s_rho_0_b,
                                                  lin_space_z=lin_space_z,
                                                  dim_points=dim_points)

    fig, axs = plt.subplots(1, 1,
                            figsize=(8, 6))
    axs.plot(theta_axis,
             sllgs_data[:, 0][::-1],
             '+-',
             label='sllgs')
    axs.plot(fp_theta,
             ddata_fit,
             label='fit')
    axs.plot(fp_theta,
             ddata_a,
             '--',
             label='A')
    axs.plot(fp_theta,
             ddata_b,
             '--',
             label='B')
    axs.grid()
    axs.legend()
    if plot_intermediate:
        plt.show()
    else:
        plt.savefig(f'fit_{data_file.split("/")[-1]}.png')

    # use fitted
    s_rho_0_a = s_rho_0_fit
    # use default
    # s_rho_0_a = s_rho_0_a

    sn = analytical.get_sn(Nmax)
    fp_data_a = analytical.get_sw_continuous_prob(
        s_rho_0=s_rho_0_a,
        tau=tau,
        delta=delta,
        i=i,
        h=h,
        rho_0_at_pi=rho_0_at_pi,
        compute_fvm=False,
        compute_analytical_sw=True,
        compute_analytical_manual=compute_analytical_manual,
        dim_points=dim_points,
        lin_space_z=lin_space_z,
        t_step=tau_step,
        sn=sn)
    fp_data_b = analytical.get_sw_continuous_prob(
        s_rho_0=s_rho_0_b,
        tau=tau,
        delta=delta,
        i=i,
        h=h,
        rho_0_at_pi=rho_0_at_pi,
        compute_fvm=False,
        compute_analytical_sw=True,
        compute_analytical_manual=compute_analytical_manual,
        dim_points=dim_points,
        lin_space_z=lin_space_z,
        t_step=tau_step,
        sn=sn)
    fp_time = fp_data_a['time']*np.abs(llg_o._get_tau_d())
    if compute_analytical_manual:
        fp_a_ps_manual = fp_data_a['manual_prob']
        # fp_b_ps_manual = fp_data_b['manual_prob']
    else:
        fp_a_ps_manual = None
        # fp_a_psmanual = None
    fp_a_ps = fp_data_a['analytical_prob']
    fp_b_ps = fp_data_b['analytical_prob']
    fp_data_a = fp_data_a['pdf'].T
    fp_data_b = fp_data_b['pdf'].T
    fp_a_switching_idx = np.min([len(fp_a_ps)-1,
                                 np.searchsorted(fp_a_ps, 0.5)])
    fp_b_switching_idx = np.min([len(fp_b_ps)-1,
                                 np.searchsorted(fp_b_ps, 0.5)])
    print(f'fp_a_switching_idx{fp_a_switching_idx}')
    print(f'fp_b_switching_idx{fp_b_switching_idx}')
    print(f'fp_time: {fp_time.shape}')
    print(f'fp_theta: {fp_theta.shape}')
    print(f'fp_data_a: {fp_data_a.shape}')

    ##########################################################
    # plot
    ##########################################################
    if False and plot_intermediate:
        fig, axs = plt.subplots(3, 1,
                                sharex=True,
                                figsize=(8, 6))
        cmap = plt.cm.cividis
        # cmap = plt.cm.PuBu_r

        # s-LLGS
        v_min = np.max([1e-8, np.min(sllgs_data)])
        v_max = np.max(sllgs_data)

        sllgs_data[sllgs_data < v_min] = v_min
        fp_data_a[fp_data_a < v_min] = v_min
        fp_data_b[fp_data_b < v_min] = v_min

        print(f'ranges: {v_min}, {v_max}')
        ax0 = axs[0]
        ax0.pcolormesh(1e9*sllgs_time,
                       np.pi-fp_theta,
                       sllgs_data,
                       # vmin=v_min,
                       norm=mcolors.LogNorm(vmin=v_min,
                                            vmax=v_max),
                       cmap=cmap,
                       # shading='auto')
                       shading='gouraud')
        ax0.set_ylabel(r'$10^5$ s-LLGS sims'
                       r'$\theta$ [rad]')
        ax00 = ax0.twinx()
        ax00.plot([1e9*sllgs_time[sllgs_sw_idx],
                  1e9*sllgs_time[sllgs_sw_idx]],
                  [0, 1],
                  '--', color='tomato')
        ax00.plot([1e9*(t_pulse),
                  1e9*(t_pulse)],
                  [0, 1],
                  '--', color='tomato')
        # axx.plot([0, 1e9*time_tols[-1]],
        #          [0.5, 0.5],
        #          '--', color='tomato')
        ax00.plot(1e9*sllgs_time, sllgs_sw_ps,
                  '--', color='whitesmoke')
        # ax11.grid()
        ax00.set_ylabel(r'Switching probability')
        ax00.annotate(f'sw @ {1e9*sllgs_time[sllgs_sw_idx]:.2f} ns',
                      xy=(1e9*sllgs_time[sllgs_sw_idx], 0.5),
                      xytext=(1e9*sllgs_time[sllgs_sw_idx]+1, 0.5),
                      color='whitesmoke'
                      )
        ax00.annotate(f'write ends @ {1e9*(t_pulse):.2f} ns',
                      xy=(1e9*(t_pulse), 0.5),
                      xytext=(1e9*(t_pulse) + 1, 0.5),
                      color='whitesmoke'
                      )

        ax2 = axs[1]
        ax3 = axs[2]

        # FP a
        ax2.pcolormesh(1e9*fp_time, fp_theta, fp_data_b,
                       norm=mcolors.LogNorm(vmin=v_min,
                                            vmax=v_max),
                       cmap=cmap,
                       shading='auto')  # , vmax=v_max)
        # ax2.set_title('FPE simulations (Maxwell Prob)')
        ax2.set_ylabel(
            'FPE simulation\n(Maxwell Prob)\n'
            r'$\theta$ [rad]'
        )
        ax2.plot([1e9*fp_time[fp_a_switching_idx],
                  1e9*fp_time[fp_a_switching_idx]],
                 [0, np.pi],
                 '--', color='tomato')
        ax22 = ax2.twinx()
        ax22.plot(1e9*fp_time, fp_a_ps,
                  '--', color='whitesmoke')
        ax22.set_ylabel(r'Switching probability')
        ax22.plot([1e9*(t_pulse),
                  1e9*(t_pulse)],
                  [0, 1],
                  '--', color='tomato')

        # FP b
        ax3.pcolormesh(1e9*fp_time, fp_theta, fp_data_b,
                       norm=mcolors.LogNorm(vmin=v_min,
                                            vmax=v_max),
                       cmap=cmap,
                       shading='auto')  # , vmax=v_max)
        # ax4.set_title('FPE simulations (Literature)')
        ax3.set_ylabel(
            'FPE simulation\n(Literature Prob)\n'
            r'$\theta$ [rad]'
        )
        ax3.set_xlabel(r'time [ns]')
        ax3.plot([1e9*fp_time[fp_b_switching_idx],
                  1e9*fp_time[fp_b_switching_idx]],
                 [0, np.pi],
                 '--', color='tomato')
        ax22 = ax3.twinx()
        ax22.plot(1e9*fp_time, fp_b_ps,
                  '--', color='whitesmoke')
        ax22.plot([1e9*(t_pulse),
                  1e9*(t_pulse)],
                  [0, 1],
                  '--', color='tomato')
        ax22.set_ylabel(r'Switching probability')

        # ax1.set_xlim([0., 1e9*xlim])
        # ax2.set_xlim([0., 1e9*xlim])
        # ax3.set_xlim([0., 1e9*xlim])
        # ax4.set_xlim([0., 1e9*xlim])

        ax22.annotate(f'write ends @ {1e9*(t_pulse):.2f} ns',
                      xy=(1e9*(t_pulse), 0.5),
                      xytext=(1e9*(t_pulse) + 1, 0.5),
                      color='whitesmoke'
                      )
        ax22.annotate(f'write ends @ {1e9*(t_pulse):.2f} ns',
                      xy=(1e9*(t_pulse), 0.5),
                      xytext=(1e9*(t_pulse) + 1, 0.5),
                      color='whitesmoke'
                      )

        ax2.annotate(f'sw @ {1e9*fp_time[fp_a_switching_idx]:.2f} ns',
                     xy=(1e9*fp_time[fp_a_switching_idx], 0.5),
                     xytext=(1e9*fp_time[fp_a_switching_idx]+1, 0.5),
                     color='whitesmoke'
                     )
        ax3.annotate(f'sw @ {1e9*fp_time[fp_b_switching_idx]:.2f} ns',
                     xy=(1e9*fp_time[fp_b_switching_idx], 0.5),
                     xytext=(1e9*fp_time[fp_b_switching_idx]+1, 0.5),
                     color='whitesmoke'
                     )
        for ax in axs:
            ax.set_yticks([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi])
            ax.set_yticklabels([r'$0$', r'$\pi/4$',
                                r'$\pi/2$', r'$3\pi/4$', r'$\pi$'])

        plt.show()
    return {'fp_time': fp_time,
            'fp_theta': fp_theta,
            'fp_data': fp_data_b,
            'fp_ps': fp_a_ps,
            'fp_ps_manual': fp_a_ps_manual,
            'sllgs_time': sllgs_time,
            'sllgs_theta': theta_axis,
            'sllgs_data': sllgs_data,
            'sllgs_ps': sllgs_sw_ps
            }


################################
# comparison
################################

if compute_analytical_manual:
    ps_fp_manual = [None] * len(t_delays_ns)

plot_idx = 3
for idx in range(len(sllgs_files)):
    # if idx%4 != plot_idx:
    #     continue
    print('---------------------', idx)
    data = analyze_s_llgs_tolerances(
        sllgs_files[idx],
        sllgs_time_files[idx],
        t_delays_ns[idx]*1e-9,
        I0_uA[idx],
        compute_analytical_manual=compute_analytical_manual,
        plot_intermediate=plot_intermediate)
    ps_sslgs[idx] = data['sllgs_ps']
    time_sslgs[idx] = data['sllgs_time']
    ps_fp[idx] = data['fp_ps']
    time_fp[idx] = data['fp_time']
    if compute_analytical_manual:
        ps_fp_manual[idx] = data['fp_ps_manual']

fig, ax = plt.subplots(1, 1,
                       sharex=True,
                       figsize=(8, 6))
markers = itertools.cycle(
    ('o', '*', 'd', '1', ',', '+', '.', 's', 'X', 'x'))
for idx in range(len(sllgs_files)):
    # if idx%4 != plot_idx:
    #     continue
    print('---------------------', idx)
    color = next(colors)
    marker = next(markers)
    np.savetxt(f'dummy_sllgs_wer_{idx}.csv',
               np.array([time_sslgs[idx], 1-ps_sslgs[idx]]))
    ax.plot(1e9*time_sslgs[idx], 1-ps_sslgs[idx],
            # label=sllgs_files[idx].split('/')[-1],
            label='10000 s-LLGS walks',
            marker=marker,
            color=color)
    ax.plot(1e9*time_fp[idx],
            1-ps_fp[idx],
            '--',
            # label=f'fp {sllgs_files[idx]}',
            label='Fokker-Plank',
            color=color)
    if compute_analytical_manual:
        ax.plot(1e9*time_fp[idx],
                1-ps_fp_manual[idx],
                ':',
                # label=sllgs_files[idx],
                color=color)
# ax.plot(1e9*fp_time, 1-fp_b_ps, label='fpb')
# ax.plot(1e9*time, 1-sw_ps, '--', label='sllgs')
ax.set_title('WER over time')
ax.set_xlabel('time [a.u.]')
ax.set_ylabel('WER')
ax.set_yscale('log', base=10)
ax.legend()
ax.grid()
plt.show()
