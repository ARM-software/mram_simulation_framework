#!/usr/bin/env python
# coding: utf-8
#
# Copyright (c) 2020-2021 Arm Ltd.
# All rights reserved.
#
# SPDX-License-Identifier: BSD-3-Clause

"""Plot s-LLGS/FPE evolution.

Please, setup all the required parameters.
Inputs are the files generated by stochastic_multithread_simulation.py
"""

import numpy as np
import matplotlib.pyplot as plt
import itertools
import matplotlib.colors as mcolors

import fokker_plank.analytical.analytical as analytical
import python_compact_model.sllgs_solver as sllgs_solver
import sllgs_importer as sllgs_i

######################################################################
# PARAMS for building llgs object
# these should match the ones you used for the s-LLGS simulation
######################################################################
# Define a macrospin mesh (i.e. one discretisation cell).
Z0 = 1
INITIAL_M = None  # np.array([0.01, 0.01, z0])  # vector in x direction
DIAM = 50e-9
T_FL = 1.e-9
TEMP = 300
K_I_0 = 1.0e-3
ALPHA = 0.01  # Gilbert damping
MS = 1.2e6  # magnetisation saturation (A/m)
# Zeeman (external field) validation
HEXT = (0., 0., 0.)  # low external magnetic field (A/m) (test anisotropy)
# stt params
EPS_PRIME = 0.0                 # [FITTING] constant
P = 0.75
LAMBDA = 1.

###################################
SLLGS_FILES = [
    'path_to_csv_file_exported_by_stochastic_multithread_simulation.py',
]
SLLGS_TIME_FILES = [
    'path_to_time_csv_file_exported_by_stochastic_multithread_simulation.py',
]
I0_UA = [50]*len(SLLGS_FILES)
T_DELAYS_NS = [5]*len(SLLGS_FILES)

COMPUTE_ANALYTICAL_MANUAL = False
PLOT_INTERMEDIATE = False


COLORS = itertools.cycle(mcolors.TABLEAU_COLORS)
MARKERS = itertools.cycle(
    ('o', '*', 'd', '1', ',', '+', '.', 's', 'X', 'x'))


def test_h_ext(t):
    """Set H_ext."""
    return np.array(HEXT)


def test_current(t):
    """Test current."""
    return 0.


# get Ic, tau_d etc
LLG_O = sllgs_solver.LLG(w_fl=DIAM, l_fl=DIAM, t_fl=T_FL,
                         ms=MS,
                         alpha=ALPHA,
                         k_i_0=K_I_0,
                         # thermal_stability_0=thermal_stability_0,
                         temperature=TEMP,
                         stt_mode='stt_oommf_simple',
                         p=P,
                         lambda_s=LAMBDA,
                         eps_prime=EPS_PRIME,
                         # not include temperature noise,
                         # and do not force its effects on the theta_0
                         do_thermal=False,
                         do_fake_thermal=False,
                         do_theta_windowing=False,
                         m_init=INITIAL_M,
                         # shape_ani_demag_mode=0,
                         # theta_init=0.09,
                         # [rad] pinned layer theta
                         theta_pl=0.0,
                         # [rad] pinned layer phi
                         phi_pl=0.0,
                         h_ext_cart=test_h_ext,
                         i_amp_fn=test_current)

print(f'P: {P}, P/2: {P/2}, eps: {LLG_O.get_epsilon_stt(1)}')

##############################################################################
# importing raw data
# ~/SharePoint/ProjectEnergyScalableMRAM/docs/essderc_2021/raw_data
##############################################################################


def analyze_s_llgs_tolerances(
        data_file, time_file, t_delay, I0_uA,
        llg_o=LLG_O,
        compute_analytical_manual=False,
        plot_intermediate=True,
        dim_points=1000):
    """Analyze s-LLGS."""
    # get all data, note it is not delayed anymore
    (sllgs_time, sllgs_data,
            sllgs_sw_idx, sllgs_sw_ps) = sllgs_i.process_sllgs_data(
        data_file, time_file, 0, dim_points)
    theta_axis = np.linspace(np.pi, 0, dim_points)

    # debug sllgs
    # return {
    #         'sllgs_time': sllgs_time,
    #         'sllgs_theta': theta_axis,
    #         'sllgs_data': sllgs_data,
    #         'sllgs_ps': sllgs_sw_ps
    #         }
    ########################################################################
    # Initializations
    I0 = np.sign(Z0)*I0_uA*1e-6

    lin_space_z = False
    L0_max = 200
    Nmax = L0_max

    # maxwell_loc = -0.016632336229383336
    # maxwell_scale = 0.041628860303107654
    maxwell_loc = None
    maxwell_scale = None

    # i, h, delta
    # llg_o.ic = llg_o.ic * 1.1
    # llg_o.tau_d = llg_o.tau_d * 1.1
    print(f'Ic from: {llg_o._get_Ic()}')
    ic = np.abs(llg_o._get_Ic())
    # ic = 4*llg.c_E * llg_o.alpha * llg_o.thermal_stability * \
    #     llg.c_KB * temperature / (llg.c_hbar * llg_o.get_epsilon_stt(1)*2)
    print(f'Ic from compact modeling: {ic}')
    print(f'epsilon: {llg_o.get_epsilon_stt(1)}')
    i = I0/ic
    print(f'[debug] i: {i}')
    h = 0
    delta = llg_o.thermal_stability

    # FP Data
    xlim = sllgs_time[-1]
    tau = xlim/np.abs(llg_o._get_tau_d())
    tau_step = 0.2e-9/np.abs(llg_o._get_tau_d())
    t_pulse = 60e-9
    print(f't_final: {xlim}')
    print(f'tau: {tau} i: {i}')
    lin_space_z = False
    rho_0_at_pi = llg_o.theta_init > np.pi/2

    rho_0_time_idx = np.searchsorted(sllgs_time, t_delay+t_delay/50)
    print(f'\n->fitting rho at time {sllgs_time[rho_0_time_idx]}\n')
    print(f'\n->mean: {np.mean(sllgs_data[0][:, rho_0_time_idx])}')
    print(f'\n->std: {np.std(sllgs_data[0][:, rho_0_time_idx])}')

    # sllgs_data has (data, time)
    s_rho_0_fit = np.polynomial.legendre.legfit(
        x=np.cos(theta_axis),
        # sllgs is normalized to 1 already
        y=sllgs_data[0][:, rho_0_time_idx][::-1],
        deg=L0_max)
    _, rho_0_a, s_rho_0_a = analytical.get_state_rho_0(
        delta=delta,
        do_maxwell=True,
        maxwell_loc=maxwell_loc,
        maxwell_scale=maxwell_scale,
        L0=Nmax,
        lin_space_z=lin_space_z,
        rho_0_at_pi=rho_0_at_pi)
    _, _, s_rho_0_b = analytical.get_state_rho_0(delta=delta,
                                                 do_maxwell=False,
                                                 L0=Nmax,
                                                 dim_points=dim_points,
                                                 lin_space_z=lin_space_z,
                                                 rho_0_at_pi=rho_0_at_pi)

    # fergar01
    # s_rho_0_fit = s_rho_0_b

    fp_theta, ddata_fit = analytical.untangle_state(s_rho_0_fit,
                                                    dim_points=dim_points,
                                                    lin_space_z=lin_space_z)
    fp_theta, ddata_a = analytical.untangle_state(s_rho_0_a,
                                                  lin_space_z=lin_space_z,
                                                  dim_points=dim_points)
    fp_theta, ddata_b = analytical.untangle_state(s_rho_0_b,
                                                  lin_space_z=lin_space_z,
                                                  dim_points=dim_points)

    fig, axs = plt.subplots(1, 1,
                            figsize=(8, 6))
    axs.plot(theta_axis,
             sllgs_data[0][:, rho_0_time_idx][::-1],
             '+-',
             label='sllgs')
    axs.plot(fp_theta,
             ddata_fit,
             label='fit')
    axs.plot(fp_theta,
             ddata_a,
             '--',
             label='A')
    axs.plot(fp_theta,
             ddata_b,
             '--',
             label='B')
    axs.grid()
    axs.legend()
    if plot_intermediate:
        plt.show()
    else:
        plt.savefig(f'fit_{data_file.split("/")[-1]}.png')

    # use fitted
    s_rho_0_a = s_rho_0_fit
    # use default
    # s_rho_0_a = s_rho_0_a

    sn = analytical.get_sn(Nmax)
    fp_data_a = analytical.get_sw_continuous_prob(
        s_rho_0=s_rho_0_a,
        tau=tau,
        delta=delta,
        i=i,
        h=h,
        rho_0_at_pi=rho_0_at_pi,
        compute_fvm=False,
        compute_analytical_sw=True,
        compute_analytical_manual=compute_analytical_manual,
        dim_points=dim_points,
        lin_space_z=lin_space_z,
        t_step=tau_step,
        sn=sn)
    fp_data_b = analytical.get_sw_continuous_prob(
        s_rho_0=s_rho_0_b,
        tau=tau,
        delta=delta,
        i=i,
        h=h,
        rho_0_at_pi=rho_0_at_pi,
        compute_fvm=False,
        compute_analytical_sw=True,
        compute_analytical_manual=compute_analytical_manual,
        dim_points=dim_points,
        lin_space_z=lin_space_z,
        t_step=tau_step,
        sn=sn)
    fp_time = fp_data_a['time']*np.abs(llg_o._get_tau_d())
    if compute_analytical_manual:
        fp_a_ps_manual = fp_data_a['manual_prob']
        # fp_b_ps_manual = fp_data_b['manual_prob']
    else:
        fp_a_ps_manual = None
        # fp_a_psmanual = None
    fp_a_ps = fp_data_a['analytical_prob']
    fp_b_ps = fp_data_b['analytical_prob']
    fp_data_a = fp_data_a['pdf'].T
    fp_data_b = fp_data_b['pdf'].T
    fp_a_switching_idx = np.min([len(fp_a_ps)-1,
                                 np.searchsorted(fp_a_ps, 0.5)])
    fp_b_switching_idx = np.min([len(fp_b_ps)-1,
                                 np.searchsorted(fp_b_ps, 0.5)])
    print(f'fp_a_switching_idx{fp_a_switching_idx}')
    print(f'fp_b_switching_idx{fp_b_switching_idx}')
    print(f'fp_time: {fp_time.shape}')
    print(f'fp_theta: {fp_theta.shape}')
    print(f'fp_data_a: {fp_data_a.shape}')

    ##########################################################
    # plot
    ##########################################################
    if False and plot_intermediate:
        fig, axs = plt.subplots(3, 1,
                                sharex=True,
                                figsize=(8, 6))
        cmap = plt.cm.cividis
        # cmap = plt.cm.PuBu_r

        # s-LLGS
        v_min = np.max([1e-8, np.min(sllgs_data[0])])
        v_max = np.max(sllgs_data[0])

        sllgs_data[0][sllgs_data[0] < v_min] = v_min
        fp_data_a[fp_data_a < v_min] = v_min
        fp_data_b[fp_data_b < v_min] = v_min

        print(f'ranges: {v_min}, {v_max}')
        ax0 = axs[0]
        ax0.pcolormesh(1e9*sllgs_time,
                       np.pi-fp_theta,
                       sllgs_data[0],
                       # vmin=v_min,
                       norm=mcolors.LogNorm(vmin=v_min,
                                            vmax=v_max),
                       cmap=cmap,
                       # shading='auto')
                       shading='gouraud')
        ax0.set_ylabel(r'$10^5$ s-LLGS sims'
                       r'$\theta$ [rad]')
        ax00 = ax0.twinx()
        ax00.plot([1e9*sllgs_time[sllgs_sw_idx],
                  1e9*sllgs_time[sllgs_sw_idx]],
                  [0, 1],
                  '--', color='tomato')
        ax00.plot([1e9*(t_pulse),
                  1e9*(t_pulse)],
                  [0, 1],
                  '--', color='tomato')
        # axx.plot([0, 1e9*time_tols[-1]],
        #          [0.5, 0.5],
        #          '--', color='tomato')
        ax00.plot(1e9*sllgs_time, sllgs_sw_ps,
                  '--', color='whitesmoke')
        # ax11.grid()
        ax00.set_ylabel(r'Switching probability')
        ax00.annotate(f'sw @ {1e9*sllgs_time[sllgs_sw_idx]:.2f} ns',
                      xy=(1e9*sllgs_time[sllgs_sw_idx], 0.5),
                      xytext=(1e9*sllgs_time[sllgs_sw_idx]+1, 0.5),
                      color='whitesmoke'
                      )
        ax00.annotate(f'write ends @ {1e9*(t_pulse):.2f} ns',
                      xy=(1e9*(t_pulse), 0.5),
                      xytext=(1e9*(t_pulse) + 1, 0.5),
                      color='whitesmoke'
                      )

        ax2 = axs[1]
        ax3 = axs[2]

        # FP a
        ax2.pcolormesh(1e9*fp_time, fp_theta, fp_data_b,
                       norm=mcolors.LogNorm(vmin=v_min,
                                            vmax=v_max),
                       cmap=cmap,
                       shading='auto')  # , vmax=v_max)
        # ax2.set_title('FPE simulations (Maxwell Prob)')
        ax2.set_ylabel(
            'FPE simulation\n(Maxwell Prob)\n'
            r'$\theta$ [rad]'
        )
        ax2.plot([1e9*fp_time[fp_a_switching_idx],
                  1e9*fp_time[fp_a_switching_idx]],
                 [0, np.pi],
                 '--', color='tomato')
        ax22 = ax2.twinx()
        ax22.plot(1e9*fp_time, fp_a_ps,
                  '--', color='whitesmoke')
        ax22.set_ylabel(r'Switching probability')
        ax22.plot([1e9*(t_pulse),
                  1e9*(t_pulse)],
                  [0, 1],
                  '--', color='tomato')

        # FP b
        ax3.pcolormesh(1e9*fp_time, fp_theta, fp_data_b,
                       norm=mcolors.LogNorm(vmin=v_min,
                                            vmax=v_max),
                       cmap=cmap,
                       shading='auto')  # , vmax=v_max)
        # ax4.set_title('FPE simulations (Literature)')
        ax3.set_ylabel(
            'FPE simulation\n(Literature Prob)\n'
            r'$\theta$ [rad]'
        )
        ax3.set_xlabel(r'time [ns]')
        ax3.plot([1e9*fp_time[fp_b_switching_idx],
                  1e9*fp_time[fp_b_switching_idx]],
                 [0, np.pi],
                 '--', color='tomato')
        ax22 = ax3.twinx()
        ax22.plot(1e9*fp_time, fp_b_ps,
                  '--', color='whitesmoke')
        ax22.plot([1e9*(t_pulse),
                  1e9*(t_pulse)],
                  [0, 1],
                  '--', color='tomato')
        ax22.set_ylabel(r'Switching probability')

        # ax1.set_xlim([0., 1e9*xlim])
        # ax2.set_xlim([0., 1e9*xlim])
        # ax3.set_xlim([0., 1e9*xlim])
        # ax4.set_xlim([0., 1e9*xlim])

        ax22.annotate(f'write ends @ {1e9*(t_pulse):.2f} ns',
                      xy=(1e9*(t_pulse), 0.5),
                      xytext=(1e9*(t_pulse) + 1, 0.5),
                      color='whitesmoke'
                      )
        ax22.annotate(f'write ends @ {1e9*(t_pulse):.2f} ns',
                      xy=(1e9*(t_pulse), 0.5),
                      xytext=(1e9*(t_pulse) + 1, 0.5),
                      color='whitesmoke'
                      )

        ax2.annotate(f'sw @ {1e9*fp_time[fp_a_switching_idx]:.2f} ns',
                     xy=(1e9*fp_time[fp_a_switching_idx], 0.5),
                     xytext=(1e9*fp_time[fp_a_switching_idx]+1, 0.5),
                     color='whitesmoke'
                     )
        ax3.annotate(f'sw @ {1e9*fp_time[fp_b_switching_idx]:.2f} ns',
                     xy=(1e9*fp_time[fp_b_switching_idx], 0.5),
                     xytext=(1e9*fp_time[fp_b_switching_idx]+1, 0.5),
                     color='whitesmoke'
                     )
        for ax in axs:
            ax.set_yticks([0, np.pi/4, np.pi/2, 3*np.pi/4, np.pi])
            ax.set_yticklabels([r'$0$', r'$\pi/4$',
                                r'$\pi/2$', r'$3\pi/4$', r'$\pi$'])

        plt.show()
    return {'fp_time': fp_time,
            'fp_theta': fp_theta,
            'fp_data': fp_data_b,
            'fp_ps': fp_a_ps,
            'fp_ps_manual': fp_a_ps_manual,
            'sllgs_time': sllgs_time,
            'sllgs_theta': theta_axis,
            'sllgs_data': sllgs_data[0],
            'sllgs_ps': sllgs_sw_ps
            }


def plot_results(sllgs_files=SLLGS_FILES,
                 sllgs_time_files=SLLGS_TIME_FILES,
                 t_delays_ns=T_DELAYS_NS,
                 plot_intermediate=PLOT_INTERMEDIATE,
                 I0s_uA=I0_UA,
                 llg_os=LLG_O,
                 compute_analytical_manual=COMPUTE_ANALYTICAL_MANUAL,
                 ):
    """Plot results for comparison."""
    if compute_analytical_manual:
        ps_fp_manual = [None] * len(t_delays_ns)

    ps_sslgs = [None] * len(t_delays_ns)
    time_sslgs = [None] * len(t_delays_ns)
    ps_fp = [None] * len(t_delays_ns)
    time_fp = [None] * len(t_delays_ns)

    for idx in range(len(sllgs_files)):
        print('---------------------', idx)
        data = analyze_s_llgs_tolerances(
            data_file=sllgs_files[idx],
            time_file=sllgs_time_files[idx],
            t_delay=t_delays_ns[idx]*1e-9,
            I0_uA=I0s_uA[idx],
            llg_o=llg_os[idx],
            compute_analytical_manual=compute_analytical_manual,
            plot_intermediate=plot_intermediate)
        ps_sslgs[idx] = data['sllgs_ps']
        time_sslgs[idx] = data['sllgs_time']
        ps_fp[idx] = data['fp_ps']
        time_fp[idx] = data['fp_time']
        if compute_analytical_manual:
            ps_fp_manual[idx] = data['fp_ps_manual']

    fig, ax = plt.subplots(1, 1,
                           sharex=True,
                           figsize=(8, 6))
    for idx in range(len(sllgs_files)):
        print('---------------------', idx)
        color = next(COLORS)
        marker = next(MARKERS)
        np.savetxt(f'dummy_sllgs_wer_{idx}.csv',
                   np.array([time_sslgs[idx], 1-ps_sslgs[idx]]))
        ax.plot(1e9*(time_sslgs[idx])-t_delays_ns[idx], 1-ps_sslgs[idx],
                label=sllgs_files[idx].split('/')[-1],
                # label='10000 s-LLGS walks',
                marker=marker,
                color=color)
        ax.plot(1e9*time_fp[idx],
                1-ps_fp[idx],
                '--',
                # label=f'fp {sllgs_files[idx]}',
                label='Fokker-Plank',
                color=color)
        if compute_analytical_manual:
            ax.plot(1e9*time_fp[idx],
                    1-ps_fp_manual[idx],
                    ':',
                    # label=sllgs_files[idx],
                    color=color)
    # ax.plot(1e9*fp_time, 1-fp_b_ps, label='fpb')
    # ax.plot(1e9*time, 1-sw_ps, '--', label='sllgs')
    ax.set_title('WER over time')
    ax.set_xlabel('time [a.u.]')
    ax.set_ylabel('WER')
    ax.set_yscale('log', base=10)
    ax.legend()
    ax.grid()
    # plt.savefig('wer.png')
    plt.show()


################################
# comparison
################################
if __name__ == "__main__":
    plot_results()
